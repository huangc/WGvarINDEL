#!/bin/bash
#PBS -m abe
#PBS -l nodes=1:ppn=20,vmem=40gb,walltime=24:00:00
#PBS -N x2-WGindel
#PBS -j oe

module add python
module add blat

# Aims: To investigate the Whole-Genome (WG) insertion/deletion (indel) profile of rice genomic samples under TALEN treatment.
# Author: Chun-Yuan Huang, Ph.D.
# Last Update: 2/12/2016

##-------------------------------------------
## Workflow description:
#1. Blat of sample contigs (by SOAP-denovo assembly) against WG reference.
#2. Generate filtered blat hits table for contigs that contain gaps whose total length
#   larger than the defined size (e.g. GAP_MINSIZE=100, defined in the source file).
#3. Calculate the Q_gapStarts, Q_gapSizes, T_gapStarts and T_gapSizes based on each gap using the block info
#   from the Blat result, where Q is for Query (the samples) and T is for Target (the reference genome)
#4. Generate indel tables for each insertion and deletion.
#5. Make indel summary table that combines same indels from all samples in each row based on the indel features
#6. Use the indel summary table to retrieve indel sequences.

cd $PBS_O_WORKDIR
source ./0SOURCE
cd ${run_DIR}

#-----
#1. Blat of sample contigs (by SOAP-denovo assembly) against WG reference.
# psl header is below. rep_match is Number of matching bases that are part of repeats. \
# Q is for Query, T is for Target, or Sample/Reference in Blastn.
# block_count is Number of blocks in the alignment. blockSizes is Comma-separated list of sizes of each block.
# match(#1), mis-match(#2), rep_match(#3), nCount(#4), Q_gap_count(#5), Q_gap_bases(#6), T_gap_count(#7), T_gap_bases(#8), strand(#9), Q_name(#10), Q_size(#11), Q_start(#12), Q_end(#13), T_name(#14), T_size(#15), T_start(#16), T_end(#17), block_count(#18), blockSizes(#19), qStarts(#20), tStarts(#21).
# psl have gap info in fields #5 (Q_gap_count), #6 (Q_gap_bases), #7 (T_gap_count), #8 (T_gap_bases)
# psl can be further simplified to the best representatives using pslReps

# for i in ${SAMPLE}
# do
# QUERY=${i}-${SEQ}
# QUERYNAME=${i}.${SEQNAME}
# blat -t=dna -q=dna -out=psl -minIdentity=${PERC_IDENTITY} -minScore=${MIN_SCORE} -mask=lower \
# ${prereq_DIR}/${REFSEQ} ${prereq_DIR}/${QUERY} blat.${DB_REFSEQ}.${QUERYNAME}.psl
# pslReps -singleHit blat.${DB_REFSEQ}.${QUERYNAME}.psl blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psr

# done

#-----
#2. Generate filtered blat hits table for contigs that contain gaps whose total length larger than the defined size (GAP_MINSIZE=100 bp).
#
for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
tail -n+6 blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl > blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer
awk -v gap_minnum="${GAP_MINNUM}" -v gap_minsize="${GAP_MINSIZE}" '{ OFS="\t"; if ( $5 > gap_minnum && $6 > gap_minsize ) print $0 }'\
 blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer > blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer.Q.awk
awk -v gap_minnum="${GAP_MINNUM}" -v gap_minsize="${GAP_MINSIZE}" '{ OFS="\t"; if ( $7 > gap_minnum && $8 > gap_minsize ) print $0 }'\
 blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer > blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer.T.awk
cat blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer.Q.awk blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.tailer.T.awk | sort -k14,14 \
 > blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.awk

echo "match mis-match rep_match nCount Q_gap_count Q_gap_bases T_gap_count T_gap_bases \
strand Q_name Q_size Q_start Q_end T_name T_size T_start T_end \
block_count blockSizes qStarts tStarts" | cat - blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.awk \
> tmp && \mv tmp blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.awk
done

#-----
#3. Calculate the Q_gapStarts, Q_gapSizes, T_gapStarts and T_gapSizes based on each gap using the block info from the Blat result, which are to be compared across all samples
#
# make a table with these info:
# Q_name(#10), T_name(#14), Q_gap_count(#5), Q_gap_bases(#6), T_gap_count(#7), T_gap_bases(#8),
# Q_size(#11), Q_start(#12), Q_end(#13), T_size(#15), T_start(#16), T_end(#17),
# block_count(#18), blockSizes(#19), qStarts(#20), tStarts(#21)

for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
awk '{ print $10,$14,$5,$6,$7,$8,$11,$12,$13,$15,$16,$17,$18,$19,$20,$21 }' blat.${DB_REFSEQ}.${QUERYNAME}.Reps.psl.awk\
 | sort -k 2.6 -n -t " " > blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.1
head -1 blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.1 > blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.2
tail -n +2 blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.1 > blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.3
done

# 
for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
\rm blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap
len=`awk 'END { print NR }' blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.3`
for ((k=1; k<=$len; k++))
do
head -$k blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.3 | tail -1 > rec
cut -d " " -f1 rec > rec.Qname
cut -d " " -f2 rec > rec.Tname
cut -d " " -f3 rec > rec.QgapCount
cut -d " " -f4 rec > rec.QgapBases
cut -d " " -f5 rec > rec.TgapCount
cut -d " " -f6 rec > rec.TgapBases

cut -d " " -f7 rec > rec.Qsize
cut -d " " -f8 rec > rec.Qstart
cut -d " " -f9 rec > rec.Qend
cut -d " " -f10 rec > rec.Tsize
cut -d " " -f11 rec > rec.Tstart
cut -d " " -f12 rec > rec.Tend

cut -d " " -f13 rec > rec.blockCount
cut -d " " -f14 rec > rec.blockSizes
cut -d " " -f15 rec > rec.qStarts
cut -d " " -f16 rec > rec.tStarts

blockCount=`cat rec.blockCount`
\rm rec.perGap
for ((m=1; m<$blockCount; m++))
do
blockSize=`cut -d"," -f $m rec.blockSizes`
# tSize=`cut -d"," -f $m rec.blockSizes`

Qname=`cat rec.Qname`
Tname=`cat rec.Tname`
QgapCount=`cat rec.QgapCount`
QgapBases=`cat rec.QgapBases`
qStart=`cut -d"," -f $m rec.qStarts`
qEnd=`expr $qStart + $blockSize`

TgapCount=`cat rec.TgapCount`
TgapBases=`cat rec.TgapBases`
tStart=`cut -d"," -f $m rec.tStarts`
tEnd=`expr $tStart + $blockSize`

next=`expr $m + 1`
qStartNext=`cut -d"," -f $next rec.qStarts`
qSizeNext=`cut -d"," -f $next rec.blockSizes`
qEndNext=`expr $qStartNext + $qSizeNext`
tStartNext=`cut -d"," -f $next rec.tStarts`
tSizeNext=`cut -d"," -f $next rec.blockSizes`
tEndNext=`expr $tStartNext + $tSizeNext`

qGapSize=`expr $qStartNext - $qEnd`
qGapStart=$qEnd
qGapEnd=$qStartNext

tGapSize=`expr $tStartNext - $tEnd`
tGapStart=$tEnd
tGapEnd=$tStartNext

echo "$Qname $Tname $QgapCount $QgapBases $TgapCount $TgapBases $blockCount $qStart $qEnd $qGapSize $qStartNext $qEndNext $tStart $tEnd $tGapSize $tStartNext $tEndNext" >> rec.perGap
done

cat rec.perGap >> blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap

done
done


#4. Generate indel tables for insertion and deletion based on the filter of GAP_MINNUM and GAP_MINSIZE 
## Using locus10036 as a typical perGap record example
# Qname Tname QgapCount QgapBases TgapCount TgapBases blockCount qStart qEnd qGapSize qStartNext qEndNext tStart tEnd tGapSize tStartNext tEndNext
# 1125885 locus10036 4 13 4 164 8 0 135 4 139 232 380 515 0 515 608
# 1125885 locus10036 4 13 4 164 8 139 232 6 238 392 515 608 1 609 763
# 1125885 locus10036 4 13 4 164 8 238 392 0 392 401 609 763 154 917 926
# 1125885 locus10036 4 13 4 164 8 392 401 0 401 425 917 926 7 933 957
# 1125885 locus10036 4 13 4 164 8 401 425 1 426 430 933 957 0 957 961
# 1125885 locus10036 4 13 4 164 8 426 430 2 432 513 957 961 0 961 1042
# 1125885 locus10036 4 13 4 164 8 432 513 0 513 2499 961 1042 2 1044 3030

# There are total of 8 blocks (blockCount=8), resulted from 4 insertions (QgapCount=4) and 4 deletions (TgapCount=4).
# The gaps due to insertions can be inferred from qGapSize of 4, 6, 1, 2 (non-zeros), sum up to 13 bp (QgapBases=13).
# The gaps due to deletions can be inferred from tGapSize of 1, 154, 7, 2 (none-zeros), sum up to 164 bp (TgapBases=164).

##-----------
for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}

awk -v gap_minnum="${GAP_MINNUM}" -v gap_minsize="${GAP_MINSIZE}" '{ OFS="\t"; if ( $5 > gap_minnum && $15 > gap_minsize ) print $0 }' blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap | sort -t " " -k2.6 -n | uniq > blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.t
echo "Qname Tname QgapCount QgapBases TgapCount TgapBases blockCount qStart qEnd qGapSize qStartNext qEndNext tStart tEnd tGapSize tStartNext tEndNext" | cat - blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.t \
> tmp && \mv tmp blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.T

awk -v gap_minnum="${GAP_MINNUM}" -v gap_minsize="${GAP_MINSIZE}" '{ OFS="\t"; if ( $3 > gap_minnum && $10 > gap_minsize ) print $0 }' blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap | sort -t " " -k2.6 -n | uniq > blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.q
echo "Qname Tname QgapCount QgapBases TgapCount TgapBases blockCount qStart qEnd qGapSize qStartNext qEndNext tStart tEnd tGapSize tStartNext tEndNext" | cat - blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.q \
> tmp && \mv tmp blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.Q

done


#5a. Make a indel summary table that combines same indels from all samples in each row based on the indel features, with the following columns:
# Tname TgapStart TgapSize Qname qGapStart qGapSize Samples, such as:
# locus12345 1114 0 1357246 2476 500 YB1;YB2;YB4;YB5;YB6;YB8;
# Note "q" (query) is for insertion, and "t" (target) is for deletion.

for indel in q t
do
cd ${run_DIR}
mkdir -p ${indel}
cd ${indel}
\rm -r *.sample
for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
cp ${run_DIR}/blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.${indel} .

len=`awk 'END { print NR }' blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.${indel}`
for ((k=1; k<=$len; k++))
do
head -$k blat.${DB_REFSEQ}.${QUERYNAME}.psl.awk.perGap.${indel} | tail -1 > rec

cut -d " " -f1 rec > rec.Qname
cut -d " " -f2 rec > rec.Tname
cut -d " " -f9 rec > rec.qEnd
cut -d " " -f10 rec > rec.qGapSize
cut -d " " -f14 rec > rec.tEnd
cut -d " " -f15 rec > rec.tGapSize

Qname=`cat rec.Qname`
Tname=`cat rec.Tname`
qEnd=`cat rec.qEnd`
qGapStart=$qEnd
qGapSize=`cat rec.qGapSize`
tEnd=`cat rec.tEnd`
tGapStart=$tEnd
tGapSize=`cat rec.tGapSize`

echo "$i" >> $Tname.$tGapStart.$tGapSize.$Qname.$qGapStart.$qGapSize.sample
done
done

#5b. MAKE A summary indel table by getting all file names of $Tname.$tGapStart.$tGapSize.$Qname.$qGapStart.$qGapSize, 
# then making the newlines in each above file into ";", so
# YB1
# YB2
# YB3
# would become 
# YB1;YB2;YB3

ls *.sample > iloci.list
for x in $(cat iloci.list)
do
awk 1 ORS=';' $x > tmp && \mv tmp $x
done

# Aggregate the above file contents about indel-sample into a table
grep '' /dev/null *.sample > iloci.table
# convert . and : into tab
sed 's/\./\t/g' iloci.table | sed 's/\:/\t/g' | \
awk '{ FS="\t"; print $1,$2,$3,$4,$5,$6,$8 }' | sort -k1.6 -n > tmp && \mv tmp iloci.table


##---------------------------
#6. Use the summary indel table iloci.table (without geneID to avoid generating duplicates) to retrieve fasta sequences.
\cp ${bin_DIR}/getTarget.py ${run_DIR}/${indel}/.
\cp iloci.table ILOCI.LIST
\cp iloci.table Seq.${indel}_Lg${GAP_MINSIZE}.table
echo "Tname tGapStart tGapSize Qname qGapStart qGapSize Samples" | cat - Seq.${indel}_Lg${GAP_MINSIZE}.table > tmp && \
\mv tmp Seq.${indel}_Lg${GAP_MINSIZE}.table

for i in ${SAMPLE}
do
grep $i ILOCI.LIST > ILOCI.LIST_${i}
len=`awk 'END { print NR }' ILOCI.LIST_${i}`
\rm Seq.${indel}_Lg${GAP_MINSIZE}_${i}.fasta

for ((k=1; k<=$len; k++))
do
head -$k ILOCI.LIST_${i} | tail -1 > rec
cut -d " " -f1 rec > rec.Tname
cut -d " " -f2 rec > rec.tGapStart
cut -d " " -f3 rec > rec.tGapSize
cut -d " " -f4 rec > rec.Qname
cut -d " " -f5 rec > rec.qGapStart
cut -d " " -f6 rec > rec.qGapSize
cut -d " " -f7 rec > rec.Samples

tGapStart=`cat rec.tGapStart`
tGapSize=`cat rec.tGapSize`
tGapEnd=`expr $tGapStart + $tGapSize`
qGapStart=`cat rec.qGapStart`
qGapSize=`cat rec.qGapSize`
qGapEnd=`expr $qGapStart + $qGapSize`
Samples=`cat rec.Samples`

if [ ${indel} == "q" ]; then 
    query=`cat rec.Qname` 
    blastdbcmd -db ${prereq_DIR}/DB_${i}_contig -entry "lcl|${query}" -dbtype nucl -outfmt "%f" -out ${i}-${query}.fa
    sed -i -e "s/>lcl|/>/" ${i}-${query}.fa
    python getTarget.py ${i}-${query}.fa ${i}-${query}_GAP_${qGapStart}_${qGapEnd} ${qGapStart} ${qGapEnd}
    sed -i "s/^>${query}/>${i}-${query}_GAP_${qGapStart}_${qGapEnd}/" ${i}-${query}_GAP_${qGapStart}_${qGapEnd}.fasta
    cat ${i}-${query}_GAP_${qGapStart}_${qGapEnd}.fasta >> Seq.${indel}_Lg${GAP_MINSIZE}_${i}.fasta
elif [ ${indel} == "t" ]; then 
    query=`cat rec.Tname` 
    python getTarget.py ${prereq_DIR}/${query}.fa ${i}-${query}_GAP_${tGapStart}_${tGapEnd} ${tGapStart} ${tGapEnd}
    sed -i "s/^>${query}/>${i}-${query}_GAP_${tGapStart}_${tGapEnd}/" ${i}-${query}_GAP_${tGapStart}_${tGapEnd}.fasta
    cat ${i}-${query}_GAP_${tGapStart}_${tGapEnd}.fasta >> Seq.${indel}_Lg${GAP_MINSIZE}_${i}.fasta
else 
    echo "This is neither insertion nor deletion" >> err_indel
fi

done
done

done

##---------------------------
#7. Report
cd ${data_DIR}
for indel in q t
do
\cp ${run_DIR}/${indel}/Seq*_Lg* .
done

rename Seq.q SeqIns Seq.q*
rename Seq.t SeqDel Seq.t*

